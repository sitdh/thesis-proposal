\subsection{\FirstTimeDefine{\ProgramGraph}{\ProgramGraphEN}} 

สำหรับโปรแกรมเขียนด้วยภาษาที่มีข้อกำหนดจัดเจนแล้ว {\ProgramGraph}\ คือ \FirstTimeDefine{\DirectedGraph}{\DirectedGraphEN} 
ซึ่งแต่ละ {\FirstTimeDefine{\Node}{\NodeEN}} แทนส่วนประกอบของชุดคำสั่ง โดย{\FirstTimeDefine{\Edge}{\EdgeEN}} แทนการไหลของการควบคุม 
หาก $i$ และ $j$ คือ {\Node}ในกราฟโปรแกรม ที่เชื่อมกันด้วย{\Edge}แบบมีทิศทางจาก $i$ ไปยัง $j$ แล้ว จะสื่อความหมายว่า 
"{\Node} $j$ จะทำงานในลำดับถัดไปหลังจากที่ $i$ ทำงานเสร็จสิ้น" \cite{Jorgensen2013} โดยเริ่มต้นด้วย{\Node}ที่มีดีกรีออก 
(Outdegree) มีค่าเป็น 1 และสิ้นสุด ณ \Node ที่มีดีกรีเข้า (Indegree) มีค่าเป็น 1 เช่นเดียวกัน ซึ่งรูปแบบความสำพันธ์ของกราฟโปรแกรมนั้น 
McCabe \cite{Watson1996} ได้กำหนดรูปแบบโครงสร้างการทำงานขั้นพื้นฐานของการพัฒนาโปรแกรม 
(The primitive operations of structured programming) \figref{fig:graphtype}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.9\textwidth]{graph-types}
    \caption{ประเภทของกราฟ}
    \label{fig:graphtype}
\end{figure}

จาก\figref{fig:pseudocodeGrading} เป็นชุดรหัสเทียมที่นำเสนอวิธีการคำนวณเกรดของนิสิตโดยรับข้อมูล โดยรับข้อมูลคะแนน (student\_score) 
และคะแนนพิเศษ (bonus\_score) ของนิสิต หากมีคะแนนเป็น 0 จะได้เกรด \emph{{\bf I}} หากนิสิตได้คะแนนต่ำกว่า 80 คะแนน 
จะได้เกรด {\emph{\bf U}} หากมีคะแนนตั้งแต่ 80 ไปจนถึง 100 คะแนน นิสิตจะได้เกรด {\emph{\bf S}} ซึ่งจากชุดรหัสเทียมนี้ 
สามารถแปลงเป็นกราฟโปรแกรม เพื่อทำความเข้าใจโครงสร้างได้ดัง{\figref{fig:programGraph} 

\begin{figure}[ht!]
    \begin{algorithm}[H]
        \begin{algorithmic}[1]
            \STATE{Program {\bf "Simple Grading"}}
            \STATE{student\_score $\gets$ receive student score}
            \STATE{bonus\_score $\gets$ receive student's bonus score}

            \IF{bonus\_score > 0}
                \IF{student\_score <= 50} 
                    \STATE{student\_score = min(50, student\_score + bonus\_score)} 
                \ELSIF{student\_score <= 70} 
                    \STATE{student\_score = min(70, student\_score + bonus\_score)}
                \ENDIF
            \ENDIF

            \STATE{grade\_letter = ""}

            \IF{student\_score < 80} 
                \STATE{grade\_letter = 'U'} 
            \ELSIF{student\_score == 0}
                \STATE{grade\_letter = 'I'} 
            \ELSIF{student\_score <= 100}
                \STATE{grade\_letter = 'S'} 
            \ENDIF

            \STATE{print(grade\_letter)}
        \end{algorithmic}
    \end{algorithm}
    \caption{ชุดรหัสเทียมสำหรับคำนวณเกรดนิสิตจากคะแนนที่ได้รับ}
    \label{fig:pseudocodeGrading}
\end{figure}


\begin{figure}[ht!]
    \centering
    \includegraphics[height=0.80\textheight]{grading-program-graph}
    % - - - - - - - - - - - - - - - - - - - -
    % \begin{tikzpicture}[node distance=2cm]
    %     % Nodes layout
    %     \node[shape=circle,draw=black] (4) {$4$};
    %     \node[shape=circle,draw=black, above left of=4] (2) {$2$};
    %     \node[shape=circle,draw=black, above right of=4] (3) {$3$};
    %     \node[shape=circle,draw=black, below left of=4] (5) {$5$};
    %     \node[shape=circle,draw=black, below left of=5] (6) {$6$};
    %     \node[shape=circle,draw=black, below right of=5] (7) {$7$};
    %     \node[shape=circle,draw=black, below left of=7] (8) {$8$};
    %     \node[shape=circle,draw=black, below right of=8] (9) {$9$};
    %     \node[shape=circle,draw=black, below left of=9] (10) {$10$};
    %     \node[shape=circle,draw=black, below of=10] (11) {$11$};
    %     \node[shape=circle,draw=black, below of=11] (12) {$12$};
    %     \node[shape=circle,draw=black, below left of=12] (13) {$13$};
    %     \node[shape=circle,draw=black, below right of=13] (14) {$14$};
    %     \node[shape=circle,draw=black, below left of=14] (15) {$15$};
    %     \node[shape=circle,draw=black, below right of=14] (16) {$16$};
    %     \node[shape=circle,draw=black, below left of=16] (17) {$17$};
    %     \node[shape=circle,draw=black, below of=17] (18) {$18$};
    %     \node[shape=circle,draw=black, below of=18] (19) {$19$};

    %     % Connected edges 
    %     % \path [->] (A) edge node[midway, above]{This works} (B);
    %     \path [->] (2) edge (3);
    %     \path [->] (3) edge node[midway, above]{T} (4);
    %     \path [->] (4) edge node[midway, above]{F} (10);

    %     \path [->] (4) edge node[midway, above]{T} (5);
    %     \path [->] (5) edge node[midway, above]{T} (6);
    %     \path [->] (5) edge node[midway, above]{F} (7);
    %     \path [->] (7) edge node[midway, above]{T} (8);
    %     \path [->] (8) edge node[midway, above]{F} (9);
    %     \path [->] (9) edge node[midway, above]{F} (10);
    %     \path [->] (10) edge (11);
    %     \path [->] (11) edge (12);
    %     % \path [->] (9) edge node[midway, above]{F} (10);

    % \end{tikzpicture}
    % - - - - - - - - - - - - - - - - - - - -
    \caption{กราฟโปรแกรมของชุดรหัสเทียมสำหรับคำนวณเกรดนิสิต}
    \label{fig:programGraph}
\end{figure}

จาก{\figref{fig:programGraph}} เป็นการนำเสนอชุดรหัสเทียมจาก{\figref{fig:pseudocodeGrading} ในรูปของกราฟโปรแกรม 
โดยที่{\Node}ที่ 2-3, 6, 8, 9, 10, 11, 13, 17, 18 และ 19 คือ{\Node}ที่แสดงถึงลำดับการดำเนินงาน 
และ{\Node} 4, 5, 6, 7, 12, 14 และ 16 เป็น{\FirstTimeDefine{\PredicateNode}{\PredicateNodeEN}} ภายในโปรแกรม 
โดยมีโหนด 2 และ 19 เป็น{\FirstTimeDefine{\sourcenode}{\sourcenodeEN}} 
และ{\FirstTimeDefine{\sinknode}{\sinknodeEN}}\ ตามลำดับ 

การนำเสนอโปรแกรมในรูปของกราฟโปรแกรมนั้นช่วยให้ผู้ทดสอบวิเคราะห์โครงสร้างของโปรแกรมจากกราฟ 
เพื่อหาข้อผิดพลาดในโครงสร้างของโปรแกรมง่ายขึ้น ด้วยการแยก{\FirstTimeDefine{\BasisPath}{\BasisPathEN}} 
จากกราฟข้างต้น โดยแต่ละ{\BasisPath}ที่แยกนั้นจะเริ่มต้นด้วย{\sourcenode} และสิ้นสุดด้วย{\sinknode}เดียวกัน ซึ่งในที่นี้คือ 2 และ 19
กำหนด{\BasisPath}ที่ต้องการทดสอบเป็น \FirstTimeDefine{\TestPath}{\TestPathEN} จากนั้นจึงวิเคราะห์{\PredicateNode}
ที่ปรากฎบน{\TestPath} พิจารณาเงื่อนไข แล้วจึงสร้างกรณีทดสอบพร้อมทั้งข้อมูลทดสอบตามวิธีการที่ผู้ทดสอบเห็นสมควร 
ซึ่งจะได้กรณีทดสอบที่ทำให้โปรแกรมดำเนินการบน{\TestPath} ที่เลือกมาได้ ยกตัวอย่างเช่น 
หากเลือก{\BasisPath}จาก{\figref{fig:programGraph}} เป็น{\TestPath} จะพบว่ามี{\PredicateNode}บน{\TestPath} 3 {\Node} 
ด้วยกัน นั่นคือ {\bf 4}, {\bf 5} และ {\bf 10} เมื่อพิจารณา{\PredicateNode}ทั้ง 3 {\Node}จะได้ข้อมูลทดสอบเป็น {\bf bonus\_score = 1} และ 
{\bf student\_score = 50} ซึ่งข้อมูลทดสอบที่สร้างขึ้นนี้สามารถทำให้โปรแกรมทำงานใน{\TestPath}ได้ 
ดังกรณีทดสอบใน\tabref{tab:simpleTestCase}

\clearpage
\begin{figure}[ht!]
    \centering
    \small{$2\ \textendash\ 3\ \textendash\ 
                (4)\ \textendash\ (5)\ \textendash\ 6\ \textendash\ 10\ \textendash\ 
                11\ \textendash\ (12)\ \textendash\ 13\ \textendash\ 18 \textendash\ 19$}
    \caption{ตัวอย่าง{\TestPath}สำหรับโปรแกรมคำนวณเกรด}
    \label{fig:testpath}
\end{figure}


\begin{table}[ht!]
    \centering
    \caption{กรณีทดสอบ}
    \label{tab:simpleTestCase}
    \begin{tabular}{|l|c|c|c|}
    \hline
    \rowcolor{LightGray}
    Case ID     & bonus\_score  & student\_score    & Expected output \\
    \hline
    SC1         & 1             & 50                & U \\
    \hline
    \end{tabular}
\end{table}

\subsection{\FirstTimeDefine{\scg}{\scgEN}}

% การพัฒนาโปรแกรมเชิงวัตถุ (Object-oriented programing: OOP) คือการจำลองพฤติกรรมและความสามารถจากชีวิตจริงออกมาเป็น
% {\FirstTimeDefine{\class}{\classEN}} \FirstTimeDefine{\method}{\methodEN} 
% และ{\FirstTimeDefine{\attribute}{\attributeEN}} \cite{kindler2011} ซึ่งโปรแกรมใด
% โปรแกรมหนึ่งที่พัฒนาขึ้นด้วยแนวคิดการพัฒนาเชิงวัตถุ นั่นคือการดำเนินงานสอดประสานร่วมกันของ{\class}ผ่าน{\method} 
% ดังนั้นเพื่อให้เข้าใจถึงความสัมพันธ์กันระหว่าง{\sourcecode} ด้วย{\scg} โดยที่แต่ละ{\Node}แทน{\class} 
% หากคลาสเรียกใช้งาน{\method}ของ{\class}อื่น ตัวอย่างเช่น หากแปลงชุดรหัสเทียมจาก \figref{fig:pseudocodeGrading} 
% เป็น{\sourcecode}ภาษาจาวา (Java) ตามแนวคิดเชิงวัตถุ 
% ด้วยแนวคิดพื้นฐานของออกแบบเชิงวัตถุ (Object-oriented design) \cite{Martin2016} นิยามไว้โดย Robert C. Martin 
% ซึ่งเป็นแนวคิดการออกแบบที่นักพัฒนานำไปใช้งานโดยทั่วไป 
การพัฒนาโปรแกรมเชิงวัตุ (Object-oriented programming: OOP) เป็นการรวมพฤติกรรม และความสามารถที่คล้ายคลึงกันเข้าไว้ด้วยกัน \cite{kindler2011}
เป็น\FirstTimeDefine{\class}{\classEN} \FirstTimeDefine{\method}{\methodEN} และ \FirstTimeDefine{\attribute}{\attributeEN} 
และเพื่อให้เข้าใจถึงการเกิดปฏิสัมพันธ์ซึ่งกันและกันระหว่าง{\class}ภายในซอฟต์แวร์ภายใต้การทดสอบ (Software under test: SUT) จาก{\sourcecode} 
ที่ได้รับมานั้น จึงจำเป็นจะต้องพิจารณา{\sourcecode}แล้วจึงนำมาสร้างเป็น \FirstTimeDefine{\scg}{\scgEN} โดยที่{\scg} 
นั้นจะใช้{\Node}แทน{\class}ทั้งหมด เชื่อมกันด้วย{\Edge}ที่กำกับด้วย{\method}ที่{\class}ใช้ปฏิสัมพันธ์กัน หากแปลง{\sourcecode}จาก
\figref{fig:pseudocodeGrading} ให้เป็น{\sourcecode}ภาษาจาวา (Java) โดยแยกออกเป็น 3 \class\ ได้แก่ \code{SimpleQuiz} 
ทำหน้าที่อ่านข้อมูลคำถามภายในชั้นเรียน \code{SimpleBonusScore} ทำหน้าที่คำนวณคะแนนเพิ่มพิเศษ และ \code{SimpleGrading} ทำหน้าที่คำนวณเกรดของนิสิต 
ดัง \figref{fig:javaQuiz} \figref{fig:javaBonusScore} และ\figref{fig:javaGrading}ตามลำดับ

\begin{figure}[ht!]
    \lstset{basicstyle=\small,style=thesiscodestyle,language=java}
    \lstinputlisting[language=Java]{related/SimpleQuiz.java}
    \caption{{\sourcecode}ภาษาจาวาสำหรับอ่านคะแนนคำถามภายในชั้นเรียน}
    \label{fig:javaQuiz}
\end{figure}

\begin{figure}[ht!]
    \lstset{basicstyle=\small,style=thesiscodestyle,language=java}
    \lstinputlisting[language=Java]{related/SimpleBonusScore.java}
    \caption{{\sourcecode}ภาษาจาวาสำหรับคำนวนคะแนนเพิ่มพิเศษ}
    \label{fig:javaBonusScore}
\end{figure}

\begin{figure}[ht!]
    \lstset{basicstyle=\small,style=thesiscodestyle}
    \lstinputlisting[language=Java]{related/SimpleGrading.java}
    \caption{{\sourcecode}ภาษาจาวาสำหรับคำนวณเกรดนิสิต}
    \label{fig:javaGrading}
\end{figure}

\clearpage
จาก\figref{fig:javaGrading} เมื่อกำหนดให้ \code{Q} แทน\class\ \code{SimpleQuiz}, \code{G} แทน{\class} \code{SimpleGrading} 
และ \code{B} แทน\class\ \code{SimpleBonusScore} โดยที่\class\ \code{SimpleGrading} เรียกใช้งาน{\method} \code{score} 
ซึ่งเป็น{\method}ของ{\class} \code{SimpleBonusScore} ผ่าน{\method} {\code{grading}} ดังนั้น{\scg}สำหรับความสัมพันธ์นี้จะเป็นดัง
{\figref{fig:scggrading}} ซึ่งในการพัฒนาจริงนั้น\class\ \code{SimpleGrading} และ\class\ \code{SimpleBonusScore}
อาจมีการเรียกใช้งานระหว่างกันมากกว่า 1 \method % ดังที่ได้แสดงใน{\figref{fig:subactualscg}}

\begin{figure}[htb!]
    \centering
    \includegraphics[width=0.8\textwidth]{simple-static-call-graph}
    % \begin{minipage}[t]{0.5\linewidth}
    %     \centering
    %     \includegraphics[width=0.8\textwidth]{simple-static-call-graph}
    %     \subcaption{{\scg}โปรแกรมคำนวณเกรดนิสิต}
    %     \label{fig:subscggrading}
    % \end{minipage}%
    % \begin{minipage}[t]{0.5\linewidth}
    %     \centering
    %     \includegraphics[width=0.8\textwidth]{simple-static-call-graph-multiple-call}
    %     \subcaption{{\scg}ของโปรแกรมในกรณีที่\code{SimpleGrading} มีการเรียกใช้งาน{\code{SimpleBonusScore}} หลาย{\method}}
    %     \label{fig:subactualscg}
    % \end{minipage}%
    \caption{{\scg}โปรแกรมคำนวณเกรดนิสิต}
    \label{fig:scggrading}
\end{figure}

% - - - - - - - - - - - - - - - - - - - -
\subsection{\FirstTimeDefine{\InfeasiblePath}{\InfeasiblePathEN}}

\InfeasiblePath คือ ทางเดินที่ไม่สามารถหาค่าทุก ๆ ความเป็นไปได้ซึ่งสอดคล้องกับ{\PredicateNode}ที่อยู่บนทางเดินนั้น 
เพื่อทำให้โปรแกรมทำงานบนเส้นทางนั้นได้ \cite{Naik2008} หากพิจารณาจากชุดรหัสเทียมใน{\figref{fig:pseudocodeGrading}} 
และกราฟใน{\figref{fig:programGraph}} ประกอบเข้าด้วยกัน จะพบว่าทางเดิน 
\code{\overline{12}\ \textendash\ 14\ \textendash\ 15 \textendash\ 18 \textendash\ 19} คือ {\bf \InfeasiblePath} 
ดังแสดงใน{\figref{fig:infeasiblePath}} เนื่องจากไม่สามารถหาค่าที่สอดคล้อง กับ\PredicateNode\ 12 และ 14 
นั่นคือ \code{student\_score \geq 80} และ \code{student\_score = 0} ได้ในทุก ๆ กรณี

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.5\textwidth]{grading-program-graph-subgraph}
    \caption{โครงสร้างของโปรแกรมที่พบ{\InfeasiblePath}}
    \label{fig:infeasiblePath}
\end{figure}


ดังนั้นการทดสอบโปรแกรมนั้นจึงจำเป็นจะต้องวิเคราะห์{\InfeasiblePath}ที่อยู่ภายในโครงสร้างของโปรแกรมเพื่อรายงานผลให้นักพัฒนาได้ทราบและแก้ไข
ต่อไปได้

\subsection{\FirstTimeDefine{\Cyclomatic}{\CyclomaticEN}}

% การวัดความซับซ้อนของโปรแกรมนั้นสามารถทำได้หลายแนวทาง ทั้งการประมาณการจากจำนวนกรณีทดสอบ 
% ที่ครอบคลุม{\sourcecode}ได้ตามระดับความครอบคลุม (Coverage level) \cite{Ferrer2013} ตามที่ต้องการ
% หรือประเมินความซับซ้อนของแผนภาพกระบวนการทางธุรกิจ (Business Process Model and Notation: BPMN) ที่จะนำโปรแกรมเข้าไปช่วยบริหารจัดการ
% \cite{Solichah2013}
ในการวัดความซับซ้อนเชิงโครงสร้างของโปรแกรมนั้น McCabe ได้กำหนด \Cyclomatic\ \cite{McCabe1976}\ 
ไว้เพื่อเป็นมาตรวัดความซับซ้อนของโปรแกรม โดยใช้การพิจารณาจากจำนวน\Node\ \Edge และ\PredicateNode\ ที่ประกอบกันภายใน\ProgramGraph\ 
ดัง\eq{eq:complexitymeasureStronglyConnected} และ \eq{eq:complexitymeasure}

\begin{align}
    v(G) &= e - n + p \label{eq:complexitymeasureStronglyConnected} \\
    v(G) &= e - n + 2p \label{eq:complexitymeasure} 
\end{align}

\begin{table}[ht!]
    \begin{tabular}{lcl}
    เมื่อ & $v(G)$    & คือ ค่า{\Cyclomatic}ที่คำนวณได้               \\
        & $e$       & คือ จำนวน{\Edge}ใน\ProgramGraph            \\
        & $n$       & คือ จำนวน{\Node}ใน\ProgramGraph            \\
        & $p$       & คือ จำนวนพื้นที่ที่เชื่อมต่อกันใน\ProgramGraph   \\
    \end{tabular}
\end{table}

โดยที่ \eq{eq:complexitymeasureStronglyConnected} จะใช้กับกราฟที่เชื่อมต่อกันแบบเข้ม (Strongly connected graph) 
นั่นคือกราฟนั้นจะต้องมีทางเดินจาก $n_j$ ไปยัง $n_k$ เสมอ แต่หากไม่ใช่แล้วจะใช้ \eq{eq:complexitymeasure} โดยจะกำหนดให้ 
$p = 1$ จาก{\ProgramGraph}ใน{\figref{fig:programGraph}} ซึ่งมี{\Edge}ทั้งสิ้น 23 เส้น และจำนวน{\Node}ทั้งสิ้น 
18 \Node\ ดังนั้นหากคำนวนระดับความซับซ้อนตาม{\Cyclomatic}ของ{\ProgramGraph}นี้ จะได้ว่า

\begin{align*}
    v(G) &= e - n + 2p \\
         &= 23 - 18 + 2 \\
    v(G) &= 7 
\end{align*}

จากคำของ McCabe แล้วโปรแกรมไม่ควรมีค่า{\Cyclomatic}มากกว่า 15 โดยที่ค่าความซับซ้อนที่แนะนำอยู่ที่ 10 \cite{McCabe1976}
